/*
We cant simply take prefix[high]-prefix[low]
coz it will give substrings that end between low and high but the substring should also start in this range thats why it will give wrong answer.
If you take prefix[high] - prefix[low-1], it would give the total number of valid substrings that end at positions from low to high, but it doesn't account for whether they start in a valid position with respect to the k constraint.
On this Our solution will be based on , first from given low index we find the max valid index till which we get substrings , and now from this validind we apply prefix[high] - prefix[validind];
After calculating that part, you use prefix[high] - prefix[validlow] to add the number of valid substrings starting beyond low and ending at high.
*/



class Solution {
public:
    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
        int left=0,right=0,n=s.size();
        int ones=0;
        int zeros=0;
        vector<int> leftmost(n,0),rightmost(n,0);
        while(right<n)
        {
            if(s[right]=='0') zeros++;
            else ones++;
            while(ones>k && zeros>k)
            {
                if(s[left]=='0') zeros--;
                else ones--;
                left++;
            }
            leftmost[right]=left;
            right++;
        }
        ones=0,zeros=0;
        left=n-1,right=n-1;
        while(right>=0)
        {
            if(s[right]=='0') zeros++;
            else ones++;
            while(ones>k && zeros>k)
            {
                if(s[left]=='0') zeros--;
                else ones--;
                left--;
            }
            rightmost[left]=right;
            right--;
        }
        
        vector<long long> prefix(n,0);
        long long cnt=0;
        for(int j=0;j<n;j++)
        {
            cnt+=j-leftmost[j]+1;
            prefix.push_back(cnt);
        }
        vector<long long> result;
        for(int i=0;i<queries.size();i++)
        {
            int low=queries[i][0];
            int high=queries[i][1];

            int validlow=min(rightmost[low],high);
            long long total=(validlow-low+1)*(validlow-low+2)/2;
            total+=prefix[high]-prefix[validlow];
            result.push_back(total);
        }


        return result;
        
    }
};
